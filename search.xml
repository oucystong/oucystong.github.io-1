<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建Hexo静态博客</title>
    <url>/2019/11/22/%E6%90%AD%E5%BB%BAHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="下载安装Hexo"><a href="#下载安装Hexo" class="headerlink" title="下载安装Hexo"></a>下载安装Hexo</h2><p>1.去网站下载node.js的LTS（长期支持版）</p><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://nodejs.org/en/</span><br></pre></td></tr></table></figure>

<p>2.切换root成用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">#输入密码</span><br></pre></td></tr></table></figure>

<p>3.查看node和npm的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>4.使用npm安装淘宝的cnpm，可使下载速度更快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局安装</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">#查看cnpm版本</span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>

<p>5.安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局安装</span><br><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>6.查看Hexo版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><p>1.建立写博客的目录BlogResources，所有的内容都在此目录中，如果过程中遇到了什么错误，直接删除Hexo目录删除重来即可。</p>
<p>2.切换到目录BlogResources中，使用下面常用的命令来创建自己博文并且发布。</p>
<p>3.Hexo的常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hexo init:在一个目录中进行hexo的初始化。</span><br><span class="line"></span><br><span class="line">hexo server:启动博客，用该命令来预览一下自己写的博客，可以通过http://localhost:4000进行本地预览查看。</span><br><span class="line"></span><br><span class="line">hexo new &quot;My New Post&quot;:新建一篇文章。</span><br><span class="line"></span><br><span class="line">hexo clean:清理一下</span><br><span class="line"></span><br><span class="line">hexo generate:把我们的文章生成为网页端的文章。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.只有使用vim编辑的时候才进去那个文章的目录进行编辑，即，上面的命令运行都是在建博客的目录下运行的，即BlogResources目录下面运行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#文章所在目录</span><br><span class="line">/Users/ethan/Documents/BlogResources/source/_posts</span><br></pre></td></tr></table></figure>

<p>2.hexo或者hexo help可以查看hexo支持的所有命令及其功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> Usage: hexo &lt;command&gt;</span><br><span class="line"> </span><br><span class="line">Commands:</span><br><span class="line"> clean     Remove generated files and cache.</span><br><span class="line"> config    Get or set configurations.</span><br><span class="line"> deploy    Deploy your website.</span><br><span class="line"> generate  Generate static files.</span><br><span class="line"> help      Get help on a command.</span><br><span class="line"> init      Create a new Hexo folder.</span><br><span class="line"> list      List the information of the site</span><br><span class="line"> migrate   Migrate your site from other system to Hexo.</span><br><span class="line"> new       Create a new post.</span><br><span class="line"> publish   Moves a draft post from _drafts to _posts folder.</span><br><span class="line"> render    Render files with renderer plugins.</span><br><span class="line"> server    Start the server.</span><br><span class="line"> version   Display version information.</span><br><span class="line"> </span><br><span class="line"> Global Options:</span><br><span class="line"> --config  Specify config file instead of using _config.yml</span><br><span class="line"> --cwd     Specify the CWD</span><br><span class="line"> --debug   Display all verbose messages in the terminal</span><br><span class="line"> --draft   Display draft posts</span><br><span class="line"> --safe    Disable all plugins and scripts</span><br><span class="line"> --silent  Hide output on console</span><br></pre></td></tr></table></figure>

<p>3.hexo help [command]可以查看command的更多信息。</p>
<h2 id="博客部署到Github上"><a href="#博客部署到Github上" class="headerlink" title="博客部署到Github上"></a>博客部署到Github上</h2><p>1.在自己的Github上New Repository，命名标准：oucystong.github.io</p>
<p>注意：用户部署个人博客的Github仓库的命名必须符合特定要求才行（Github用户名.github.io）。</p>
<p>2.在命令行中BlogResources目录下操作安装一个部署到Github上的一个插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>3.修改_config.yml，修改内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  #repo是仓库地址</span><br><span class="line">  repo: https://github.com/oucystong/oucystong.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>4.在命令行中BlogResources目录下运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Deploy your website.</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>输入Github的账号和密码，万事大吉，刷新Github的仓库，可以很多推送的内容，这就是Hexo把我们的文章推送到remote产生的文件。</p>
<p>5.测试是否可以通过一个Github的网址进行访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://oucystong.github.io/</span><br></pre></td></tr></table></figure>

<h2 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h2><p>1.一个比较流行的主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/litten/hexo-theme-yilia</span><br></pre></td></tr></table></figure>

<p>2.克隆主题到theme目录下的yilia目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>

<p>3.修改_config.yml，修改内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia</span><br><span class="line">#theme:和主题之间必须要有空格</span><br></pre></td></tr></table></figure>

<p>4.执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>5.推到remote，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="以后的个人博客地址"><a href="#以后的个人博客地址" class="headerlink" title="以后的个人博客地址"></a>以后的个人博客地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://oucystong.github.io/</span><br></pre></td></tr></table></figure>

<h2 id="小建议"><a href="#小建议" class="headerlink" title="小建议"></a>小建议</h2><p>注意问题：</p>
<p>1.所有命令的执行都是基于建立博客的根目录进行，即BlogResources，除非使用vim编辑自己的博文会切换到_post目录下面，所以时常使用pwd查看当前所在的路径。</p>
<p>2.建议使用root用户权限发布博文，发布博文时使用如下命令切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">#输入密码</span><br></pre></td></tr></table></figure>

<p>3.切换到普通用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>4.修改博文时的最好办法：切换到root用户，pwd查看当前路径，切换到博文所在路径，使用open document命令将Markdown文件以默认程序打开，比如Typora，可以以所见即所得的方式编辑Markdown文档（使用vim编辑各种配置文件还行，编辑Markdown文件有点浪费时间），编辑完之后在终端以root身份clean、generate、server预览、deploy推送到remote。</p>
<p>可能遇到的问题：open document，文档被锁定，无法编辑，直接将该文档进行复制出一个副本，对副本进行编辑，将原文件删除（不要用trash命令），将编辑好之后的新文件放入。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL多表&amp;事务</title>
    <url>/2019/11/22/MySQL%E5%A4%9A%E8%A1%A8&amp;%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. 多表查询
2. 事务
3. DCL</code></pre><a id="more"></a><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：
    select
        列名列表    多个列逗号隔开
    from
        表名列表
    where....
* 准备sql
    # 创建部门表
    CREATE TABLE dept(
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(20)
    );
    INSERT INTO dept (NAME) VALUES (&apos;开发部&apos;),(&apos;市场部&apos;),(&apos;财务部&apos;);
    # 创建员工表
    CREATE TABLE emp (
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(10),
        gender CHAR(1), -- 性别
        salary DOUBLE, -- 工资
        join_date DATE, -- 入职日期
        dept_id INT,
        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)
    );
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1);
* 笛卡尔积：
    * 有两个集合A,B,取这两个集合的所有组成情况。  number(A)*number(B)==所有的情况数目
    * 要完成多表查询，需要消除无用的数据------------消除笛卡尔积所有结果的情况中没有用的数据。
* 多表查询的分类：
    1. 内连接查询：
        1. 隐式内连接：使用where条件消除无用数据
            * 例子：
            -- 查询所有员工信息和对应的部门信息

            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

            -- 查询员工表的名称，性别。部门表的名称
            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

            -- 起别名的方式写查询，以后写sql语句使用下面的标准，好处是：方便以后在后面加注释
            SELECT 
                t1.name, -- 员工表的姓名
                t1.gender,-- 员工表的性别
                t2.name -- 部门表的名称
            FROM
                emp t1,
                dept t2
            WHERE 
                t1.`dept_id` = t2.`id`;

        2. 显式内连接：
            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件
            * 例如：
                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;    
                * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;    

        3. 内连接查询：
            1. 从哪些表中查询数据
            2. 条件是什么
            3. 查询哪些字段
    2. 外链接查询：
        1. 左外连接：
            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；
            * 查询的是左表所有数据以及其交集部分。
            * 例子：
                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;
        2. 右外连接：
            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；
            * 查询的是右表所有数据以及其交集部分。
            * 例子：
                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;
    3. 子查询：
        * 概念：查询中嵌套查询，称嵌套查询为子查询。
            -- 查询工资最高的员工信息
            -- 1 查询最高的工资是多少 9000
            SELECT MAX(salary) FROM emp;

            -- 2 查询员工信息，并且工资等于9000的
            SELECT * FROM emp WHERE emp.`salary` = 9000;

            -- 一条sql就完成这个操作。子查询
            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);

        * 子查询不同情况
            1. 子查询的结果是单行单列的：
                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =
                -- 查询员工工资小于平均工资的人
                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);
            2. 子查询的结果是多行单列的：
                * 子查询可以作为条件，使用运算符in来判断
                -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息
                SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;;
                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
                -- 子查询
                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;);
            3. 子查询的结果是多行多列的：
                * 子查询可以作为一张虚拟表参与查询
                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
                -- 子查询
                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2
                WHERE t1.id = t2.dept_id;
                -- 普通内连接
                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &apos;2011-11-11&apos;

    * 多表查询练习

            -- 部门表
            CREATE TABLE dept (
              id INT PRIMARY KEY PRIMARY KEY, -- 部门id
              dname VARCHAR(50), -- 部门名称
              loc VARCHAR(50) -- 部门所在地
            );

            -- 添加4个部门
            INSERT INTO dept(id,dname,loc) VALUES 
            (10,&apos;教研部&apos;,&apos;北京&apos;),
            (20,&apos;学工部&apos;,&apos;上海&apos;),
            (30,&apos;销售部&apos;,&apos;广州&apos;),
            (40,&apos;财务部&apos;,&apos;深圳&apos;);

            -- 职务表，职务名称，职务描述
            CREATE TABLE job (
              id INT PRIMARY KEY,
              jname VARCHAR(20),
              description VARCHAR(50)
            );

            -- 添加4个职务
            INSERT INTO job (id, jname, description) VALUES
            (1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;),
            (2, &apos;经理&apos;, &apos;管理部门员工&apos;),
            (3, &apos;销售员&apos;, &apos;向客人推销产品&apos;),
            (4, &apos;文员&apos;, &apos;使用办公软件&apos;);

            -- 员工表
            CREATE TABLE emp (
              id INT PRIMARY KEY, -- 员工id
              ename VARCHAR(50), -- 员工姓名
              job_id INT, -- 职务id
              mgr INT , -- 上级领导
              joindate DATE, -- 入职日期
              salary DECIMAL(7,2), -- 工资
              bonus DECIMAL(7,2), -- 奖金
              dept_id INT, -- 所在部门编号
              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
            );

            -- 添加员工
            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES 
            (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),
            (1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),
            (1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),
            (1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),
            (1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),
            (1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),
            (1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),
            (1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),
            (1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),
            (1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),
            (1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),
            (1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),
            (1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),
            (1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10);

            -- 工资等级表
            CREATE TABLE salarygrade (
              grade INT PRIMARY KEY,   -- 级别
              losalary INT,  -- 最低工资
              hisalary INT -- 最高工资
            );

            -- 添加5个工资等级
            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES 
            (1,7000,12000),
            (2,12010,14000),
            (3,14010,20000),
            (4,20010,30000),
            (5,30010,99990);

            -- 需求：

            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
            /*
                分析：
                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表
                    2.查询条件 emp.job_id = job.id

            */
            SELECT 
                t1.`id`, -- 员工编号
                t1.`ename`, -- 员工姓名
                t1.`salary`,-- 工资
                t2.`jname`, -- 职务名称
                t2.`description` -- 职务描述
            FROM 
                emp t1, job t2
            WHERE 
                t1.`job_id` = t2.`id`;

            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
            /*
                分析：
                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept
                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id
            */

            SELECT 
                t1.`id`, -- 员工编号
                t1.`ename`, -- 员工姓名
                t1.`salary`,-- 工资
                t2.`jname`, -- 职务名称
                t2.`description`, -- 职务描述
                t3.`dname`, -- 部门名称
                t3.`loc` -- 部门位置
            FROM 
                emp t1, job t2,dept t3
            WHERE 
                t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;

            -- 3.查询员工姓名，工资，工资等级
            /*
                分析：
                    1.员工姓名，工资 emp  工资等级 salarygrade
                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary
                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
            */
            SELECT 
                t1.ename ,
                t1.`salary`,
                t2.*
            FROM emp t1, salarygrade t2
            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;

            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级
            /*
                分析：
                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade
                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary

            */
            SELECT 
                t1.`ename`,
                t1.`salary`,
                t2.`jname`,
                t2.`description`,
                t3.`dname`,
                t3.`loc`,
                t4.`grade`
            FROM 
                emp t1,job t2,dept t3,salarygrade t4
            WHERE 
                t1.`job_id` = t2.`id` 
                AND t1.`dept_id` = t3.`id`
                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;        


            -- 5.查询出部门编号、部门名称、部门位置、部门人数

            /*
                分析：
                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表
                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)
                    3.使用子查询将第2步的查询结果和dept表进行关联查询

            */
            SELECT 
                t1.`id`,t1.`dname`,t1.`loc` , t2.total
            FROM 
                dept t1,
                (SELECT
                    dept_id,COUNT(id) total
                FROM 
                    emp
                GROUP BY dept_id) t2
            WHERE t1.`id` = t2.dept_id;        

            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询

            /*
                分析：
                    1.姓名 emp， 直接上级的姓名 emp
                        * emp表的id 和 mgr 是自关联
                    2.条件 emp.id = emp.mgr
                    3.查询左表的所有数据，和 交集数据
                        * 使用左外连接查询

            */
            /*
            select
                t1.ename,
                t1.mgr,
                t2.`id`,
                t2.ename
            from emp t1, emp t2
            where t1.mgr = t2.`id`;

            */

            SELECT 
                t1.ename,
                t1.mgr,
                t2.`id`,
                t2.`ename`
            FROM emp t1
            LEFT JOIN emp t2
            ON t1.`mgr` = t2.`id`;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍
    1. 概念：
        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。
    2. 操作：
        1. 开启事务： start transaction;
        2. 回滚：rollback;
        3. 提交：commit;
    3. 例子：
        CREATE TABLE account (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(10),
            balance DOUBLE
        );
        -- 添加数据
        INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000);
        SELECT * FROM account;
        UPDATE account SET balance = 1000;
        -- 张三给李四转账 500 元
        -- 0. 开启事务
        START TRANSACTION;
        -- 1. 张三账户 -500

        UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;;
        -- 2. 李四账户 +500
        -- 出错了...
        UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;;

        -- 发现执行没有问题，提交事务
        COMMIT;
        -- 发现出问题了，回滚事务
        ROLLBACK;

    4. MySQL数据库中事务默认自动提交
        * 事务提交的两种方式：
            * 自动提交：
                * mysql默认就是自动提交的
                * 一条DML(增删改)语句会自动提交一次事务。
            * 手动提交：
                * Oracle 数据库默认是手动提交事务
                * 需要先开启事务，再提交
        * 修改事务的默认提交方式：
            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
            * 修改默认提交方式： set @@autocommit = 0;


2. 事务的四大特征：
    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
    3. 隔离性：多个事务之间。相互独立。
    4. 一致性：事务操作前后，数据总量不变  改变前：1000+1000  改变后：500+1500
3. 事务的隔离级别（了解）
    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。
    * 存在问题：
        1. 脏读：一个事务，读取到另一个事务中没有提交的数据
        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。
    * 隔离级别：
        1. read uncommitted：读未提交
            * 产生的问题：脏读、不可重复读、幻读
        2. read committed：读已提交 （Oracle默认）
            * 产生的问题：不可重复读、幻读
        3. repeatable read：可重复读 （MySQL默认）
            * 产生的问题：幻读
        4. serializable：串行化 当一个事务操作数据库的时候，另一个事务是不能操作该数据库的，跟加锁机制相同。
            * 可以解决所有的问题

        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低
        * 数据库查询隔离级别：
            * select @@tx_isolation;
        * 数据库设置隔离级别：
            * set global transaction isolation level  隔离级别字符串;
        * 重要：
      最新数据库查询隔离级别：select @@transaction_isolation;
      早期版本的mysql中用的是tx_isolation，5.7.20版本之后改为transaction_isolation
      最新数据库设置隔离界别：
      set session transaction isolation level  隔离级别字符串;
      设置完隔离级别之后不会立即生效，关闭当前连接之后在重新打开才会生效。

    * 演示：
        set global transaction isolation level read uncommitted;
        start transaction;
        -- 转账操作
        update account set balance = balance - 500 where id = 1;
        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：
    1. DDL：操作数据库和表
    2. DML：增删改表中数据
    3. DQL：查询表中数据
    4. DCL：管理用户，授权

* DBA：数据库管理员 database administrator

* DCL：管理用户，授权
    1. 管理用户
        1. 添加用户：
            * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;;
        2. 删除用户：
            * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;;
        3. 修改用户密码：

            UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;;
            UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;;

            SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;);
            SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;);

            * 密码自带的mysql数据库中的user表下面都是加密的，我们看到的都是加密之后的形式，看不到明文密码。

            * mysql中忘记了root用户的密码？
                1. cmd -- &gt; net stop mysql 停止mysql服务
                    * 需要管理员运行该cmd
                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
                4. use mysql;
                5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;;
                6. 关闭两个窗口
                7. 打开任务管理器，手动结束mysqld.exe 的进程
                8. 以管理员打开cmd窗口，启动mysql服务：net start mysql
                9. 使用新密码登录。
        4. 查询用户：
            -- 1. 切换到mysql数据库
            USE mysql;
            -- 2. 查询user表
            SELECT * FROM USER;

            * 通配符： % 表示可以在任意主机使用用户登录数据库
            * host：主机

    2. 权限管理：
        1. 查询权限：
            -- 查询权限
            SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;;
            SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;;

        2. 授予权限：
            -- 授予权限
            grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;;
            -- 给张三用户授予所有权限，在任意数据库任意表上

            GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;;
        3. 撤销权限：
            -- 撤销权限：
            revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;;
            REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;
            -- 给张三用户撤销所有权限，在任意数据库任意表上
            REVOKE ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;;</code></pre>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL约束</title>
    <url>/2019/11/22/MySQL%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. DQL:查询语句
    1. 排序查询
    2. 聚合函数
    3. 分组查询
    4. 分页查询
2. 约束
3. 多表之间的关系
4. 范式
5. 数据库的备份和还原</code></pre><a id="more"></a><h2 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h2><pre><code>1. 排序查询
    * 语法：order by 子句
        * order by 排序字段1 排序方式1 ，排序字段2 排序方式2...
    * 排序方式：
        * ASC：升序，默认的。
        * DESC：降序。
    * 注意：
        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。
-- 排序查询
select * from student order by student.math DESC , student.english DESC ;


2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。
    1. count：计算个数
        1. 一般选择非空的列：主键
        2. count(*)  在一条记录的所有列中只要有一个列的数据不是null，就算为一条记录。
    2. max：计算最大值
    3. min：计算最小值
    4. sum：计算和
    5. avg：计算平均值
    * 注意：聚合函数的计算，排除null值。
        解决方案：
            1. 选择不包含非空的列进行计算
            2. IFNULL函数
-- 聚合函数
select count(student.name) as studentnumber from student;
select count(student.id) as studentnumber from student;
select count(*) from student;
select count(ifnull(student.english,0)) from student;
select max(student.math) from student;
select min(student.math) from student;
select sum(student.math) from student;
select sum(student.english) from student;-- 排除了null的值
select avg(student.math) from student;


3. 分组查询:
    1. 语法：group by 分组字段；
    2. 注意：
        1. 分组之后查询的字段：分组字段、聚合函数  其他的字段可以显示出来，但是没有什么意义！所以有意义的字段就只能写分组字段和聚合函数。
        2. where 和 having 的区别？--------面试中经常会考！！！
            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。

        -- 按照性别分组。分别查询男、女同学的平均分

        SELECT sex , AVG(math) FROM student GROUP BY sex;

        -- 按照性别分组。分别查询男、女同学的平均分,人数

        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;

        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;

        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;

        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;

4. 分页查询
    1. 语法：limit 开始的索引,每页查询的条数;
    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数
        -- 每页显示3条记录 

        SELECT * FROM student LIMIT 0,3; -- 第1页

        SELECT * FROM student LIMIT 3,3; -- 第2页

        SELECT * FROM student LIMIT 6,3; -- 第3页

        真实数据库数据最后的内容不够sql语言展示，则仅仅展示完所有真实数据，不会显示其他内容，也不会报错，产生一个“截断”的现象。
    3. limit 是一个MySQL&quot;方言&quot;   分页查询不是“方言”，各种数据库都有分页查询这个操作，但是各种数据库的实现分页查询的方式不相同。</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    
* 分类：
    1. 主键约束：primary key
    2. 非空约束：not null
    3. 唯一约束：unique
    4. 外键约束：foreign key

* 非空约束：not null，值不能为null
    1. 创建表时添加约束
        CREATE TABLE stu(
            id INT,
            NAME VARCHAR(20) NOT NULL -- name为非空
        );
    2. 创建表完后，添加非空约束
        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;
    3. 删除name的非空约束
        ALTER TABLE stu MODIFY NAME VARCHAR(20);
* 唯一约束：unique，值不能重复
        1. 创建表时，添加唯一约束
            CREATE TABLE stu(
                id INT,
                phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束
        );
        * 注意mysql中，唯一约束限定的列的值可以有多个null
        2. 删除唯一约束
                ALTER TABLE stu DROP INDEX phone_number;

        3. 在创建表后，添加唯一约束
        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;

* 主键约束：primary key。
    1. 注意：
        1. 含义：非空且唯一
        2. 一张表只能有一个字段为主键
        3. 主键就是表中记录的唯一标识

    2. 在创建表时，添加主键约束
        create table stu(
            id int primary key,-- 给id添加主键约束
            name varchar(20)
        );

    3. 删除主键
        -- 错误 alter table stu modify id int ;
        ALTER TABLE stu DROP PRIMARY KEY;

    4. 创建完表后，添加主键
        ALTER TABLE stu MODIFY id INT PRIMARY KEY;

    5. 自动增长：
        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长

        2. 在创建表时，添加主键约束，并且完成主键自增长
        create table stu(
            id int primary key auto_increment,-- 给id添加主键约束
            name varchar(20)
        );
        注意：怎么使用？
        在insert into数据的时候，直接把id列给null值，这个id列就会在前一条记录的id值基础上自动加1，当然我们也可以手动赋值给id，当我们手动赋值了，在自动加1的时候，是基于我们手动给的值进行自动增长加1操作的。
        总结就是本条记录的id值是总是根据上一条记录的id值自动增长加1。
        3. 删除自动增长
        ALTER TABLE stu MODIFY id INT;
        4. 添加自动增长
        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;


* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。---外键约束是相对于多个表来说的。数据库的设计中要尽量避免数据的冗余。
                    让多个表之间产生关联，保证数据的正确性，不会产生误删现象和添加不符合规范数据的现象。
    1. 在创建表时，可以添加外键
        * 语法：
            create table 表名(
                ....
                外键列,
                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称，一般都关联主表的主键列)
            );
        *两个小知识点：
            * constraint:约束的意思
            * 给外键起名:emp_dept_id-------------------表1名_表2名_表2的列名称（一般是主键列）
            * 添加了外键约束之后，外键列和主表列的数据就不能够随便乱改了。
    2. 删除外键
        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;

    3. 创建表之后，添加外键
        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);
    4. 级联操作
        1. 添加级联操作
            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 
                    FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;
        2. 分类：
            1. 级联更新：ON UPDATE CASCADE 
            2. 级联删除：ON DELETE CASCADE 
            3. 可以设置一个，也可以同时设置两个
            4. 设计级联操作，有好处也有坏处，使用的时候要具体问题具体分析。</code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系
    1. 分类：
        1. 一对一(了解)：
            * 如：人和身份证
            * 分析：一个人只有一个身份证，一个身份证只能对应一个人
        2. 一对多(多对一)：
            * 如：部门和员工
            * 分析：一个部门有多个员工，一个员工只能对应一个部门
        3. 多对多：
            * 如：学生和课程
            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
    2. 实现关系：
        1. 一对多(多对一)：
            * 如：部门和员工
            * 实现方式：在多的一方建立外键，指向一的一方的主键。
        2. 多对多：
            * 如：学生和课程
            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键
            * 联合主键是不能重复的
        3. 一对一(了解)：
            * 如：人和身份证
            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。
            * 如果是一对一的关系，我们通常合在一个表中，没必要分成两个表之后添加唯一约束的外键约束用来指向主表的主键列。
    3. 案例
        -- 创建旅游线路分类表 tab_category
        -- cid 旅游线路分类主键，自动增长
        -- cname 旅游线路分类名称非空，唯一，字符串 100
        CREATE TABLE tab_category (
            cid INT PRIMARY KEY AUTO_INCREMENT,
            cname VARCHAR(100) NOT NULL UNIQUE
        );

        -- 创建旅游线路表 tab_route
        /*
        rid 旅游线路主键，自动增长
        rname 旅游线路名称非空，唯一，字符串 100
        price 价格
        rdate 上架时间，日期类型
        cid 外键，所属分类
        */
        CREATE TABLE tab_route(
            rid INT PRIMARY KEY AUTO_INCREMENT,
            rname VARCHAR(100) NOT NULL UNIQUE,
            price DOUBLE,
            rdate DATE,
            cid INT,
            FOREIGN KEY (cid) REFERENCES tab_category(cid)
        );

        /*创建用户表 tab_user
        uid 用户主键，自增长
        username 用户名长度 100，唯一，非空
        password 密码长度 30，非空
        name 真实姓名长度 100
        birthday 生日
        sex 性别，定长字符串 1
        telephone 手机号，字符串 11
        email 邮箱，字符串长度 100
        */
        CREATE TABLE tab_user (
            uid INT PRIMARY KEY AUTO_INCREMENT,
            username VARCHAR(100) UNIQUE NOT NULL,
            PASSWORD VARCHAR(30) NOT NULL,
            NAME VARCHAR(100),
            birthday DATE,
            sex CHAR(1) DEFAULT &apos;男&apos;,
            telephone VARCHAR(11),
            email VARCHAR(100)
        );

        /*
        创建收藏表 tab_favorite
        rid 旅游线路 id，外键
        date 收藏时间
        uid 用户 id，外键
        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次
        */
        CREATE TABLE tab_favorite (
            rid INT, -- 线路id
            DATE DATETIME,
            uid INT, -- 用户id
            -- 创建复合主键
            PRIMARY KEY(rid,uid), -- 联合主键
            FOREIGN KEY (rid) REFERENCES tab_route(rid),
            FOREIGN KEY(uid) REFERENCES tab_user(uid)
        );

2. 数据库设计的范式
* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        

        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

注意：充分理解下面的各个范式可根据---学生信息表---来进行分析理解
    * 分类：
        1. 第一范式（1NF）：每一列都是不可分割的原子数据项
        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）
            * 几个概念：
                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数
                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
                    例如：（学号，课程名称） --&gt; 分数
                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
                    例如：（学号，课程名称） -- &gt; 姓名
                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A。
                    例如：学号--&gt;系名，系名--&gt;系主任
                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。
                    例如：该表中码为：（学号，课程名称）
                    * 主属性：码属性组中的所有属性
                    * 非主属性：除了码属性组的属性的其他属性

        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>每一天都需要进行数据库的备份，防止数据丢失。
1. 命令行：
    * 语法：
        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径
        * 还原：
            1. 登录数据库
            2. 创建数据库
            3. 使用数据库
            4. 执行文件。source 文件路径
2. 图形化工具：
  * 使用DataGrip数据库客户端进行数据库的备份和还原
    * 备份
    选中数据库，右键选择dump with mysqldump，提示框有两个中亚内容进行填写。
      * path to mysqldump:这里填写安装mysql的时候mysqldump的目录
      * EthandeMacBook-Pro:bin ethan$ type mysqldump
                mysqldump is /usr/local/mysql/bin/mysqldump
            * outpath:这里填写数据库要导出的位置
            * 备份文件名可以自定义
    * 还原
    右键选择新建一个Schema，Schema就是数据库的意思，选中新建的该数据库右键选择Run sql script，把刚才备份的内容选中执行即可。
3.小知识点：
  * 注意：打开备份的文件，可以看到备份的内容其实是一些sql语句</code></pre>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2019/11/22/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 数据库的基本概念</span><br><span class="line">2. MySQL数据库软件</span><br><span class="line">   1. 安装</span><br><span class="line">   2. 卸载</span><br><span class="line">   3. 配置</span><br><span class="line">3. SQL</span><br></pre></td></tr></table></figure><a id="more"></a>

<h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB
2. 什么数据库？
    * 用于存储和管理数据的仓库。Excel？存储+管理
3. 数据库的特点：
    1. 持久化存储数据的。其实数据库就是一个文件系统
    2. 方便存储和管理数据
    3. 使用了统一的方式操作数据库 -- SQL
4. 常见的数据库软件
    * 参见《MySQL基础.pdf》</code></pre><h2 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h2><pre><code>1. 安装
    * 参见《MySQL基础.pdf》  默认端口：3306
2. 卸载
    1. 去mysql的安装目录找到my.ini文件
        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
    2. 卸载MySQL
    3. 删除C:/ProgramData目录下的MySQL文件夹。

3. 配置
    * MySQL服务启动
        1. 手动（每次都是手动打开Mysql服务）或者自动（开机自动启动）
        2. cmd--&gt; services.msc 打开服务的窗口
        3. 使用管理员打开cmd
            * net start mysql : 启动mysql的服务
            * net stop mysql:关闭mysql服务
    * MySQL登录
        1. mysql -uroot -p密码
        2. mysql -hip -uroot -p连接目标的密码
        3. mysql --host=ip --user=root --password=连接目标的密码
    * MySQL退出
        1. exit
        2. quit
    注意：Mac下载了Mysql之后需要进行环境变量的配置，才可以在命令行中使用Mysql的相关命令。
    在~/.bash_profile中追加  PATH=$PATH:/usr/local/mysql/bin
    使其发挥作用：source ~/.bash_profile

    * MySQL目录结构
        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;
            * 配置文件 my.ini
        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
            * 几个概念
                * 数据库：文件夹
                * 表：文件
                * 数据：数据
        3.通过Mac偏好设置中的配置就可以看到上述的内容，在terminal中要会进行查看，善于使用open在finder中展示，datadir普通用户是进不去的，使用sudo su进入到文件夹中。</code></pre><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><pre><code>1.什么是SQL？
    Structured Query Language：结构化查询语言
    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。

2.SQL通用语法
    1. SQL 语句可以单行或多行书写，以分号结尾。show databases;
    2. 可使用空格和缩进来增强语句的可读性。
    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。
    4. 3 种注释
        * 单行注释: -- 注释内容 或 #注释内容(mysql特有) 
        * 多行注释: /*注释*/
        * 单行注释中--的方式必须要有空格，其余没说明的情况就是不需要有空格。

3. SQL分类
    1) DDL(Data Definition Language)数据定义语言
        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
    2) DML(Data Manipulation Language)数据操作语言
        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
    3) DQL(Data Query Language)数据查询语言
        用来查询数据库中表的记录(数据)。关键字：select, where 等
    4) DCL(Data Control Language)数据控制语言(了解)
        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h3 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h3><pre><code>1. 操作数据库：CRUD
    1. C(Create):创建
        * 创建数据库：
            * create database 数据库名称;
        * 创建数据库，判断不存在，再创建：
            * create database if not exists 数据库名称;
        * 创建数据库，并指定字符集
            * create database 数据库名称 character set 字符集名;
        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
            * create database if not exists db4 character set gbk;
    2. R(Retrieve)：查询
        * 查询所有数据库的名称:
            * show databases;
            * datadir下面有三个文件夹也就是有三个database，但是为什么我们在终端显示的时候会有四个呢？
            information_schema：描述mysql数据库的信息的，比如有哪些表？以后要学习视图会用到，并没有实际的物理文件。
            mysql：核心数据库，存了很多的表
            performance_schema：对性能提升做操作的数据库，存了很多表
            sys：随便动，这是一个空的数据库
            没事别乱动上面的几个数据库的内容。

        * 查询某个数据库的字符集:查询某个数据库的创建语句
            * show create database 数据库名称;
    3. U(Update):修改
        * 修改数据库的字符集
            * alter database 数据库名称 character set 字符集名称;
    4. D(Delete):删除
        * 删除数据库
            * drop database 数据库名称;
        * 判断数据库存在，存在再删除
            * drop database if exists 数据库名称;
    5. 使用数据库
        * 查询当前正在使用的数据库名称
            * select database();
        * 使用数据库
            * use 数据库名称;


2. 操作表
    1. C(Create):创建
        1. 语法：
            create table 表名(
                列名1 数据类型1,
                列名2 数据类型2,
                ....
                列名n 数据类型n
            );
            * 注意：最后一列，不需要加逗号（,）
            * 数据库类型：
                1. int：整数类型
                    * age int,
                2. double:小数类型
                    * score double(5,2)
                3. date:日期，只包含年月日，yyyy-MM-dd
                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss
                5. timestamp:时间戳类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss    
                    * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值

                6. varchar：字符串
                    * name varchar(20):姓名最大20个字符
                    * zhangsan 8个字符  张三 2个字符


        * 创建表
            create table student(
                id int,
                name varchar(32),
                age int ,
                score double(4,1),
                birthday date,
                insert_time timestamp
            );
        * 复制表：
            * create table 表名 like 被复制的表名;          
    2. R(Retrieve)：查询
        * 查询某个数据库中所有的表名称
            * show tables;
        * 查询表结构
            * desc 表名;  description
    3. U(Update):修改
        1. 修改表名
            alter table 表名 rename to 新的表名;
        2. 修改表的字符集
            alter table 表名 character set 字符集名称;
        3. 添加一列
            alter table 表名 add 列名 数据类型;
        4. 修改列名称 类型
            alter table 表名 change 列名 新列别 新数据类型;//改列名和类型
            alter table 表名 modify 列名 新数据类型;//只改类型
        5. 删除列
            alter table 表名 drop 列名;
    4. D(Delete):删除
        * drop table 表名;
        * drop table  if exists 表名 ;</code></pre><ul>
<li>客户端图形化工具：SQLYog</li>
<li>Mac端有哪些好用的数据库客户端软件？Workbench这是Mysql官方的数据库客户端。DataGrip是jetbrain大厂的数据库客户端，很好用。</li>
</ul>
<h3 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h3><pre><code>1. 添加数据：
    * 语法：
        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);
    * 注意：
        1. 列名和值要一一对应。
        2. 如果表名后，不定义列名，则默认给所有列添加值
            insert into 表名 values(值1,值2,...值n);
        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来
2. 删除数据：
    * 语法：
        * delete from 表名 [where 条件]
    * 注意：
        1. 如果不加条件，则删除表中所有记录。
        2. 如果要删除所有记录
            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作
            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。
3. 修改数据：
    * 语法：
        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];

    * 注意：
        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h3 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h3><pre><code>* select * from 表名;

1. 语法：
    select
        字段列表  多个字段逗号分隔
    from
        表名列表  多个表名逗号分隔
    where
        条件列表
    group by
        分组字段  分组（男生组和女生组）
    having
        分组之后的条件
    order by
        排序   升序和降序
    limit
        分页限定


2. 基础查询
    1. 多个字段的查询
        select 字段名1，字段名2... from 表名；
        * 注意：
            * 如果查询所有字段，则可以使用*来替代字段列表。
    2. 去除重复：
        * distinct
        保证结果集中的两条记录完全一样才可以去重。
    3. 计算列
        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
            * 表达式1：哪个字段需要判断是否为null
            * 如果该字段为null后的替换值。
    4. 起别名：
        * as：as也可以省略，用一个或者多个空格代替

示例代码：
-- 查询姓名和年龄
select student.name,student.age from student;
-- 查询地址
select student.address from student;
-- 去除重复
select distinct student.address from student;
-- 保证结果集中的两条记录完全一样才可以去重。
select distinct student.name,student.address from student;
-- 四则运算
select student.name,student.math,student.english,student.math+student.english from student;
-- 四则运算定义别名
select student.name as 名字,student.math as 数学,student.english as 英语 from student;
-- ifnull函数的使用
select student.name,student.math,student.english,student.math+ifnull(student.english,0) as 总分 from student;


3. 条件查询
    1. where子句后跟条件
    2. 运算符
        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;或者!=
        * BETWEEN...AND  包含两边的值
        * IN(集合) 
        * LIKE：模糊查询
            * 占位符：
                * _:单个任意字符
                * %:多个任意字符（包括零个字符）
                * 在某些特殊的情况下，查询的条件丽需要使用下划线或者百分号，不希望sql把下划线和百分号当成通配符使用，这就需要使用到转义字符，mysql使用反斜杠\作为转义字符。标准sql语句并没有提供反斜杠\的转义字符，而是使用escape关键字显示进行转义。
-- 标准sql中选出名字以下划线开头的学生
select * from student where student.name like &apos;\_%&apos; escape &apos;\&apos;;
        * IS NULL    IS NOT NULL  NULL值不能使用=或者!=来进行判断，只能通过IS NULL或者IS NOT NULL
        * and  或 &amp;&amp; 推荐使用英文的
        * or  或 || 推荐使用英文的
        * not  或 !  推荐使用英文的

            -- 查询年龄大于20岁

            SELECT * FROM student WHERE age &gt; 20;

            SELECT * FROM student WHERE age &gt;= 20;

            -- 查询年龄等于20岁
            SELECT * FROM student WHERE age = 20;

            -- 查询年龄不等于20岁
            SELECT * FROM student WHERE age != 20;
            SELECT * FROM student WHERE age &lt;&gt; 20;

            -- 查询年龄大于等于20 小于等于30

            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;
            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;
            SELECT * FROM student WHERE age BETWEEN 20 AND 30;

            -- 查询年龄22岁，18岁，25岁的信息
            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25;
            SELECT * FROM student WHERE age IN (22,18,25);

            -- 查询英语成绩为null
            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断

            SELECT * FROM student WHERE english IS NULL;

            -- 查询英语成绩不为null
            SELECT * FROM student WHERE english  IS NOT NULL;
            -- 查询姓马的有哪些？ like
            SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;;
            -- 查询姓名第二个字是化的人
            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;
            -- 查询姓名是3个字的人
            SELECT * FROM student WHERE NAME LIKE &apos;___&apos;;
            -- 查询姓名中包含德的人
      SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;</code></pre><p>​                </p>
<p>​    </p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC课堂笔记</title>
    <url>/2018/05/09/JDBC%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. JDBC基本概念
2. 快速入门
3. 对JDBC中各个接口和类详解</code></pre><a id="more"></a><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库
    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。

例如：
Person接口    Worker实现类（实现了Person接口）   Person p=new Worker();   p.eat();

2. 快速入门：
    * 步骤：
        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar--里面有驱动的java源代码和class文件，只需要倒入class文件的jar包即可。
            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下--libs目录建在module下面，和src是同级目录。
            2.右键--&gt;Add As Library
        2. 注册驱动
        3. 获取数据库连接对象 Connection
        4. 定义sql
        5. 获取执行sql语句的对象 Statement
        6. 执行sql，接受返回结果
        7. 处理结果
        8. 释放资源

    * 代码实现：
          //1. 导入驱动jar包
        //2.注册驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //3.获取数据库连接对象
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);
        //4.定义sql语句
        String sql = &quot;update account set balance = 500 where id = 1&quot;;
        //5.获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();
        //6.执行sql
        int count = stmt.executeUpdate(sql);
        //7.处理结果
        System.out.println(count);
        //8.释放资源
        stmt.close();
        conn.close();

3. 详解各个对象：
    1. DriverManager：驱动管理对象
        * 功能：
            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar
                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 
                写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//把该全类名的class文件加载进内存，有一些代码被自动执行，这一部分代码放在静态代码块中。
                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块
                 static {
                        try {
                            java.sql.DriverManager.registerDriver(new Driver());
                        } catch (SQLException E) {
                            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
                        }
                    }

                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。
                mysql-connector-java-5.1.37-bin/METAINF/services/java.sql.Driver
            2. 获取数据库连接：
                * 方法：static Connection getConnection(String url, String user, String password) 
                * 参数：
                    * url：指定连接的路径
                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称
                        * 例子：jdbc:mysql://localhost:3306/db3
                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称
                    * user：用户名
                    * password：密码 
                * 查看mysql在本机上的端口：
                    * 登陆mysql，执行show global variables like &apos;port&apos;;
    2. Connection：数据库连接对象
        1. 功能：
            1. 获取执行sql 的对象
                * Statement createStatement()
                * PreparedStatement prepareStatement(String sql)  
            2. 管理事务：
                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
                * 提交事务：commit() 
                * 回滚事务：rollback() 
    3. Statement：执行sql的对象
        1. 执行sql
            1. boolean execute(String sql) ：可以执行任意的sql 了解 
            2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。
            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句
        2. 练习：
            1. account表 添加一条记录
            2. account表 修改记录
            3. account表 删除一条记录

            代码：
                Statement stmt = null;
                Connection conn = null;
                try {
                    //1. 注册驱动
                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                    //2. 定义sql
                    String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;;
                    //3.获取Connection对象
                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);
                    //4.获取执行sql的对象 Statement
                    stmt = conn.createStatement();
                    //5.执行sql
                    int count = stmt.executeUpdate(sql);//影响的行数
                    //6.处理结果
                    System.out.println(count);
                    if(count &gt; 0){
                        System.out.println(&quot;添加成功！&quot;);
                    }else{
                        System.out.println(&quot;添加失败！&quot;);
                    }

                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                } catch (SQLException e) {
                    e.printStackTrace();
                }finally {
                    //stmt.close();
                    //7. 释放资源
                    //避免空指针异常
                    if(stmt != null){
                        try {
                            stmt.close();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                    }

                    if(conn != null){
                        try {
                            conn.close();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                    }
                }

    4. ResultSet：结果集对象,封装查询结果
        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
        * getXxx(参数):获取数据
            * Xxx：代表数据类型   如： int getInt() ,    String getString()
            * 参数：
                1. int：代表列的编号,从1开始   如： getString(1)
                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)

        * 注意：
            * 使用步骤：
                1. 游标向下移动一行
                2. 判断是否有数据
                3. 获取数据

               //循环判断游标是否是最后一行末尾。
                while(rs.next()){
                    //获取数据
                    //6.2 获取数据
                    int id = rs.getInt(1);
                    String name = rs.getString(&quot;name&quot;);
                    double balance = rs.getDouble(3);

                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);
                }

        * 练习：
            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
                1. 定义Emp类
                2. 定义方法 public List&lt;Emp&gt; findAll(){}
                3. 实现方法 select * from emp;
                提示1：遍历获取数据、创建emp对象并且赋值、装载集合、
                提示2：最后申请的资源最先释放
                提示3：封装对象使用List集合
                提示4：循环中如果每次都new一个对象的话，就会浪费堆内存的空间，可以在循环外面new一个对象，在循环里面使用这个对象，实现对象的复用，使用完之后将这个对象复原为一个新对象以便于下次循环使用这个对象的时候确定这是一个新对象。
    5. PreparedStatement：执行sql的对象    extend Statement
        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题
            1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a
            2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 

        2. 解决sql注入问题：使用PreparedStatement对象来解决
        3. 预编译的SQL（动态sql）：参数使用?作为占位符
        4. 步骤：
            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            2. 注册驱动
            3. 获取数据库连接对象 Connection
            4. 定义sql
                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;
            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) 
            6. 给？赋值：
                * 方法： setXxx(参数1,参数2)
                    * 参数1：？的位置编号 从1 开始
                    * 参数2：？的值
                    * 具体的使用查看API文档
            7. 执行sql，接受返回结果，不需要传递sql语句
            8. 处理结果
            9. 释放资源

        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作
            1. 可以防止SQL注入
            2. 效率更高
            3. 我们通常使用JDBC来进行表中数据的增删改查，即操作DML和DQL语句，对于DDL通常是设计好数据库和表之后供我们进行操作的，对于DCL更加用不到我们去操作了，通常是由DBA去操作，作为Java开发人员对于这部分的内容了解即可。
            4. 预编译sql就是执行动态sql，动态sql不会产生sql注入的问题，但是静态sql（字符串拼接的sql语句）很容易出现sql注入的问题。</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写
* 提示：各种工具类一般是为了方便进行调用都使用static进行修饰，即通常定义静态方法。
* 分析：
    1. 注册驱动也抽取
    2. 抽取一个方法获取连接对象
        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。
        * 解决：配置文件  开发中很常用的方法
            jdbc.properties
                url=
                user=
                password=
                driver=
    3. 抽取一个方法释放资源


* 代码实现：
    public class JDBCUtils {
    private static String url;
    private static String user;
    private static String password;
    private static String driver;
    /**
     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块
     * 静态代码块会随着类的加载而执行，并且只会执行一次。
     */
    static{
        //读取资源文件，获取值。

        try {
            //1. 创建Properties集合类。
            Properties pro = new Properties();

            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);
            String path = res.getPath();
            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties
            //2. 加载文件
           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));
            pro.load(new FileReader(path));

            //3. 获取数据，赋值
            url = pro.getProperty(&quot;url&quot;);
            user = pro.getProperty(&quot;user&quot;);
            password = pro.getProperty(&quot;password&quot;);
            driver = pro.getProperty(&quot;driver&quot;);
            //4. 注册驱动
            Class.forName(driver);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    /**
         * 获取连接
         * @return 连接对象
         */
      public static Connection getConnection() throws SQLException {
          return DriverManager.getConnection(url, user, password);
      }

    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(Statement stmt,Connection conn){
        if( stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

        /**
         * 释放资源-- 重载
         * @param stmt
         * @param conn
         */
        public static void close(ResultSet rs,Statement stmt, Connection conn){
            if( rs != null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if( stmt != null){
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if( conn != null){
              try {
                  conn.close();
              } catch (SQLException e) {
                  e.printStackTrace();
              }
          }
    }
    }

* 练习：
    * 需求：
        1. 通过键盘录入用户名和密码
        2. 判断用户是否登录成功
            * select * from user where username = &quot;&quot; and password = &quot;&quot;;
            * 如果这个sql有查询结果，则成功，反之，则失败

    * 步骤：
        1. 创建数据库表 user
            CREATE TABLE USER(
                id INT PRIMARY KEY AUTO_INCREMENT,
                username VARCHAR(32),
                PASSWORD VARCHAR(32)

            );

            INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;);
            INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;);

        2. 代码实现：
            public class JDBCDemo9 {

                public static void main(String[] args) {
                    //1.键盘录入，接受用户名和密码
                    Scanner sc = new Scanner(System.in);
                    System.out.println(&quot;请输入用户名：&quot;);
                    String username = sc.nextLine();
                    System.out.println(&quot;请输入密码：&quot;);
                    String password = sc.nextLine();
                    //2.调用方法
                    boolean flag = new JDBCDemo9().login(username, password);
                    //3.判断结果，输出不同语句
                    if(flag){
                        //登录成功
                        System.out.println(&quot;登录成功！&quot;);
                    }else{
                        System.out.println(&quot;用户名或密码错误！&quot;);
                    }            
          }
                    /**
                     * 登录方法
                     */
                    public boolean login(String username ,String password){
                        if(username == null || password == null){
                            return false;
                        }
                        //连接数据库判断是否登录成功
                        Connection conn = null;
                        Statement stmt =  null;
                        ResultSet rs = null;
                        //1.获取连接
                        try {
                            conn =  JDBCUtils.getConnection();
                            //2.定义sql
                            String sql = &quot;select * from user where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos; &quot;;
                            //3.获取执行sql的对象
                            stmt = conn.createStatement();
                            //4.执行查询
                            rs = stmt.executeQuery(sql);
                            //5.判断
                           /* if(rs.next()){//如果有下一行，则返回true
                                return true;
                            }else{
                                return false;
                            }*/
                           return rs.next();//如果有下一行，则返回true

                        } catch (SQLException e) {
                            e.printStackTrace();
                        }finally {
                            JDBCUtils.close(rs,stmt,conn);
                        }
                        return false;
                    }
                }</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。
2. 操作：
    1. 开启事务
    2. 提交事务
    3. 回滚事务
3. 使用Connection对象来管理事务
    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
        * 在执行sql之前开启事务
    * 提交事务：commit() 
        * 当所有sql都执行完提交事务
    * 回滚事务：rollback() 
        * 在catch中回滚事务

4. 代码：
    public class JDBCDemo10 {

        public static void main(String[] args) {
            Connection conn = null;
            PreparedStatement pstmt1 = null;
            PreparedStatement pstmt2 = null;

            try {
                //1.获取连接
                conn = JDBCUtils.getConnection();
                //开启事务
                conn.setAutoCommit(false);

                //2.定义sql
                //2.1 张三 - 500
                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;
                //2.2 李四 + 500
                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;
                //3.获取执行sql对象
                pstmt1 = conn.prepareStatement(sql1);
                pstmt2 = conn.prepareStatement(sql2);
                //4. 设置参数
                pstmt1.setDouble(1,500);
                pstmt1.setInt(2,1);

                pstmt2.setDouble(1,500);
                pstmt2.setInt(2,2);
                //5.执行sql
                pstmt1.executeUpdate();
                // 手动制造异常
                int i = 3/0;

                pstmt2.executeUpdate();
                //提交事务
                conn.commit();
            } catch (Exception e) {
                //事务回滚
                try {
                    if(conn != null) {
                        conn.rollback();
                    }
                } catch (SQLException e1) {
                    e1.printStackTrace();
                }
                e.printStackTrace();
            }finally {
                JDBCUtils.close(pstmt1,conn);
                JDBCUtils.close(pstmt2,null);
            }         
            }        
        }</code></pre><p>​            </p>
]]></content>
  </entry>
</search>
